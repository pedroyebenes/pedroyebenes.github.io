<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>RSVP Prototype + EPUB</title>
  <style>
    :root{
      --bg:#0b0f14; --panel:#121926; --text:#e6edf3; --muted:#9fb0c0;
      --accent:#5cc8ff; --border:rgba(255,255,255,.08); --danger:#ff6b6b;
    }
    *{box-sizing:border-box}
    body{
      margin:0; height:100vh; display:flex; flex-direction:column;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
      background:var(--bg); color:var(--text);
    }

    header{
      padding:10px 12px;
      border-bottom:1px solid var(--border);
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
    }
    header .group{
      display:flex; gap:10px; align-items:center;
      padding:8px 10px; background:rgba(255,255,255,.04);
      border:1px solid var(--border); border-radius:12px;
    }
    label{color:var(--muted); font-size:13px}
    input[type="range"]{width:200px}
    input[type="number"]{
      width:86px; padding:6px 8px; border-radius:10px;
      border:1px solid var(--border); background:rgba(0,0,0,.25); color:var(--text);
    }
    button{
      padding:8px 10px; border-radius:12px; border:1px solid var(--border);
      background:rgba(0,0,0,.25); color:var(--text); cursor:pointer;
    }
    button:hover{background:rgba(255,255,255,.06)}
    button:active{transform:translateY(1px)}
    button:disabled{opacity:.5; cursor:not-allowed}

    main{
      flex:1;
      display:grid;
      grid-template-columns:minmax(320px, 42%) 1fr;
      gap:12px;
      padding:12px;
      min-height:0;
    }
    .panel{
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:16px;
      overflow:hidden;
      display:flex;
      flex-direction:column;
      min-height:0;
    }

    /* Panel header (title + optional controls) */
    .panelHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:10px 12px;
      border-bottom:1px solid var(--border);
      min-height:44px;
    }
    .panelHeader h2{
      margin:0;
      font-size:14px;
      color:var(--muted);
      font-weight:600;
    }
    .panelHeader .controls{
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
    }
    .panelHeader .chip{
      padding:3px 8px;
      border-radius:999px;
      border:1px solid var(--border);
      background:rgba(255,255,255,.04);
      color:var(--text);
      font-size:12px;
      white-space:nowrap;
    }
    .panelHeader .miniBtn{
      padding:6px 10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(0,0,0,.25);
      color:var(--text);
      cursor:pointer;
      white-space:nowrap;
    }
    .panelHeader .miniBtn:hover{background:rgba(255,255,255,.06)}
    .panelHeader .miniBtn:disabled{opacity:.5; cursor:not-allowed}

    /* LEFT (text/epub) */
    .leftBody{
      flex: 1;
      display:grid;
      grid-template-rows:auto auto 1fr auto;
      min-height:0;
    }
    .epubBar{
      padding:10px 12px;
      border-bottom:1px solid var(--border);
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
    }
    input[type="file"]{display:none}
    .fileBtn{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 10px; border-radius:12px; border:1px solid var(--border);
      background:rgba(0,0,0,.25); cursor:pointer; user-select:none;
      color:var(--text); font-size:14px;
      white-space:nowrap;
    }
    .fileBtn:hover{background:rgba(255,255,255,.06)}
    .epubMeta{
      color:var(--muted);
      font-size:13px;
      overflow:hidden; text-overflow:ellipsis; white-space:nowrap;
      max-width:100%;
    }

    .bookSelect{
      padding:8px 10px;
      border-radius:12px;
      border:1px solid var(--border);
      background:rgba(0,0,0,.25);
      color:var(--text);
      font-size:14px;
      max-width: 320px;
      min-width: 240px;
    }
    .bookSelect option { background: #0b0f14; color: var(--text); }

    .chapters{
      border-bottom:1px solid var(--border);
      max-height:220px;
      overflow:auto;
      padding:8px;
    }
    .chaptersHeader{
      display:flex; justify-content:space-between; align-items:center;
      padding:4px 6px 8px 6px;
      color:var(--muted); font-size:12px;
    }
    .chapterItem{
      width:100%; text-align:left;
      padding:8px 10px; border-radius:12px;
      border:1px solid transparent;
      background:transparent; color:var(--text);
      cursor:pointer;
      display:flex; gap:8px; align-items:baseline;
    }
    .chapterItem:hover{background:rgba(255,255,255,.05)}
    .chapterItem.active{border-color:rgba(92,200,255,.45); background:rgba(92,200,255,.08)}
    .chapterNum{color:var(--muted); font-size:12px; min-width:28px;}
    .chapterTitle{overflow:hidden; text-overflow:ellipsis; white-space:nowrap;}

    textarea{
      width:100%;
      height:100%;
      border:0; outline:none; resize:none;
      padding:14px;
      background:transparent; color:var(--text);
      font-size:15px; line-height:1.45;
      font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace;
      min-height:0;
    }
    .error{color:var(--danger); font-size:12px; padding:8px 12px 10px 12px;}

    /* RIGHT (RSVP) */
    .stageWrap{flex:1; display:flex; flex-direction:column; min-height:0;}
    .stage{
      flex:1; position:relative; overflow:hidden; min-height:0;
      background:radial-gradient(1200px 600px at 50% 40%, rgba(92,200,255,.08), transparent 60%);
      touch-action: none;
    }
    .anchorGuide{
      position:absolute; top:0; bottom:0; left:50%; width:2px;
      transform:translateX(-1px);
      background:rgba(92,200,255,.12);
      pointer-events:none;
    }
    .word{
      position:absolute;
      left:50%;
      top:50%;
      white-space:nowrap;
      font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace;
      font-size:clamp(42px, 7.5vw, 88px);
      line-height:1;
      text-rendering:geometricPrecision;
      transform:translate(-50%, -50%);
    }
    .word .pre{opacity:.95}
    .word .orp{font-weight:800; color:var(--accent)}
    .word .post{opacity:.95}

    /* Focus gating: show subtle focus ring when stage is "active" */
    .stage:focus-visible{
      outline:2px solid rgba(92,200,255,.35);
      outline-offset:-2px;
    }
    .stage.stageActive{
      box-shadow: inset 0 0 0 2px rgba(92,200,255,.18);
    }

    .footerBar{
      padding:10px 12px;
      border-top:1px solid var(--border);
      display:flex; justify-content:space-between;
      gap:10px; flex-wrap:wrap; align-items:center;
      color:var(--muted); font-size:13px;
    }
    .kbd{
      font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace;
      padding:2px 6px; border-radius:8px;
      border:1px solid var(--border);
      background:rgba(0,0,0,.25); color:var(--text);
    }
    .pill{
      padding:3px 8px;
      border-radius:999px;
      border:1px solid var(--border);
      background:rgba(255,255,255,.04);
      color:var(--text);
    }

    /* Desktop hide left panel */
    body.textHidden main{ grid-template-columns: 1fr; }
    body.textHidden #leftPanel{ display:none; }

    /* Phone: single pane */
    @media (max-width: 920px){
      main{ grid-template-columns:1fr; padding:10px; }
      .chapters{ max-height:180px; }
      .bookSelect{ max-width: 100%; min-width: 200px; }

      body.phoneShowRSVP #leftPanel{ display:none; }
      body.phoneShowRSVP #rightPanel{ display:flex; }

      body.phoneShowText #leftPanel{ display:flex; }
      body.phoneShowText #rightPanel{ display:none; }

      header{ gap:8px; }
      input[type="range"]{ width:160px; }

      .panelHeader{ gap:8px; }
      .panelHeader .controls{ gap:6px; }
      .panelHeader .miniBtn{ padding:6px 8px; }
    }
  </style>
</head>

<body>
  <header>
    <div class="group">
      <label for="wpmRange">WPM</label>
      <input id="wpmRange" type="range" min="100" max="900" step="10" value="350" />
      <input id="wpmNum" type="number" min="100" max="900" step="10" value="350" />
    </div>

    <div class="group">
      <label><input id="smartPauses" type="checkbox" checked /> Smart pauses</label>
      <label><input id="showGuide" type="checkbox" checked /> Anchor</label>
      <label><input id="pairShortWords" type="checkbox" /> Pair short words</label>
    </div>

    <div class="group">
      <button id="toggleTextBtn" title="Hide/Show text area">Hide text</button>
      <button id="rewindBtn" title="Rewind 10 words">‚ü≤ -10</button>
      <button id="backBtn" title="Back 1 word">‚óÄ</button>
      <button id="forwardBtn" title="Forward 1 word">‚ñ∂</button>
      <button id="resetBtn" title="Reset to cursor">Reset‚ÜíCursor</button>
    </div>
  </header>

  <main>
    <section class="panel" id="leftPanel">
      <div class="panelHeader">
        <h2>Text / EPUB ‚Äî set cursor, then play</h2>
      </div>

      <div class="leftBody">
        <div class="epubBar">
          <label class="fileBtn" for="epubFile">üìò Import EPUB</label>
          <input id="epubFile" type="file" accept=".epub,application/epub+zip" />

          <select id="bookDropdown" class="bookSelect" title="Load a book from books/">
            <option value="">Loading books‚Ä¶</option>
          </select>

          <div class="epubMeta" id="epubMeta">No book loaded.</div>
        </div>

        <div class="chapters">
          <div class="chaptersHeader">
            <div>Chapters</div>
            <div id="chapCount">0</div>
          </div>
          <div id="chapterList"></div>
        </div>

        <textarea id="editor">Paste text here.

Desktop: click RSVP display to focus it, then hold Space to play (dead-man). Release to pause.
Mobile: touch & hold the RSVP display area to play. Release to pause.

On release, the cursor jumps to the current word (or end if finished).</textarea>

        <div class="error" id="epubError"></div>
      </div>
    </section>

    <section class="panel" id="rightPanel">
      <div class="panelHeader">
        <h2>RSVP display</h2>
        <div class="controls">
          <span class="chip" id="chapterChip">Chapter: ‚Äî</span>
          <button class="miniBtn" id="prevChapterBtn" disabled title="Load previous chapter">‚Üê Prev</button>
          <button class="miniBtn" id="nextChapterBtn" disabled title="Load next chapter">Next ‚Üí</button>
        </div>
      </div>

      <div class="stageWrap">
        <div class="stage" id="stage" tabindex="0" aria-label="RSVP display (click/tap to focus)">
          <div class="anchorGuide" id="anchorGuide"></div>
          <div class="word" id="word"></div>
        </div>

        <div class="footerBar">
          <div>
            <span class="pill" id="statusPill">Paused</span>
            <span style="margin-left:10px">Index: <span id="idxLabel">0</span>/<span id="totalLabel">0</span></span>
          </div>
          <div id="footerHint"></div>
        </div>
      </div>
    </section>
  </main>

  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script>
    // ---------------------- RSVP core ----------------------
    function tokenizeWithOffsets(text){
      const tokens=[];
      const re=/\S+/g;
      let m;
      while((m=re.exec(text))!==null){
        tokens.push({value:m[0], start:m.index, end:m.index+m[0].length});
      }
      return tokens;
    }

    function tokenIndexFromCaret(tokens, caretPos){
      if(!tokens.length) return 0;
      for(let i=0;i<tokens.length;i++){
        const t=tokens[i];
        if(caretPos>=t.start && caretPos<t.end) return i;
        if(caretPos<t.start) return i;
      }
      return tokens.length-1;
    }

    function orpIndex(word){
      const len=word.length;
      if(len<=1) return 0;
      if(len<=5) return 1;
      if(len<=9) return 2;
      if(len<=13) return 3;
      return 4;
    }

    function baseMsPerWord(wpm){ return 60000/Math.max(1,wpm); }

    function extraPauseMs(tokenValue, smart){
      if(!smart) return 0;
      if(/[.?!]["')\]]?$/.test(tokenValue)) return 220;
      if(/[,;:]["')\]]?$/.test(tokenValue)) return 120;
      if(/‚Äî$/.test(tokenValue)) return 120;
      return 0;
    }

    function longWordBonusMs(tokenValue, smart){
      if(!smart) return 0;
      const bare=tokenValue.replace(/^[("'\[]+|[)"'\].,;:!?]+$/g,"");
      const len=bare.length;
      if(len>=12) return 120;
      if(len>=9) return 70;
      return 0;
    }

    const measureCanvas=document.createElement("canvas");
    const ctx=measureCanvas.getContext("2d");
    function measureTextPx(text, font){ ctx.font=font; return ctx.measureText(text).width; }

    function escapeHtml(s){
      return s.replace(/[&<>"']/g,(c)=>({"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"}[c]));
    }

    function buildWordHTML(tokenValue, anchorIdx){
      const pre=tokenValue.slice(0,anchorIdx);
      const ch=tokenValue.charAt(anchorIdx)||"";
      const post=tokenValue.slice(anchorIdx+1);
      return `<span class="pre">${escapeHtml(pre)}</span><span class="orp">${escapeHtml(ch)}</span><span class="post">${escapeHtml(post)}</span>`;
    }

    function positionWordAtAnchor(wordEl, tokenValue, anchorIdx){
      const style=getComputedStyle(wordEl);
      const fontFamily=style.fontFamily, fontSize=style.fontSize, fontStyle=style.fontStyle, fontVariant=style.fontVariant, lineHeight=style.lineHeight;
      const fontNormal=`${fontStyle} ${fontVariant} 400 ${fontSize} / ${lineHeight} ${fontFamily}`;
      const fontBold  =`${fontStyle} ${fontVariant} 800 ${fontSize} / ${lineHeight} ${fontFamily}`;
      const pre=tokenValue.slice(0,anchorIdx);
      const ch=tokenValue.charAt(anchorIdx)||"";
      const preW=measureTextPx(pre,fontNormal);
      const chW=measureTextPx(ch,fontBold);
      const shiftX=preW+(chW/2);
      wordEl.style.transform=`translate(${-shiftX}px, -50%)`;
    }

    const editor=document.getElementById("editor");
    const stageEl=document.getElementById("stage");
    const wordEl=document.getElementById("word");
    const idxLabel=document.getElementById("idxLabel");
    const totalLabel=document.getElementById("totalLabel");
    const statusPill=document.getElementById("statusPill");
    const footerHint=document.getElementById("footerHint");

    const wpmRange=document.getElementById("wpmRange");
    const wpmNum=document.getElementById("wpmNum");
    const smartPausesBox=document.getElementById("smartPauses");
    const showGuideBox=document.getElementById("showGuide");
    const pairShortWordsBox=document.getElementById("pairShortWords");
    const anchorGuide=document.getElementById("anchorGuide");

    const toggleTextBtn=document.getElementById("toggleTextBtn");
    const rewindBtn=document.getElementById("rewindBtn");
    const backBtn=document.getElementById("backBtn");
    const forwardBtn=document.getElementById("forwardBtn");
    const resetBtn=document.getElementById("resetBtn");

    const chapterChip=document.getElementById("chapterChip");
    const prevChapterBtn=document.getElementById("prevChapterBtn");
    const nextChapterBtn=document.getElementById("nextChapterBtn");

    let tokens=[], idx=0;
    let isHeld=false, timerId=null;

    // Prevent Space auto-repeat from restarting after end:
    let spaceDown = false;

    // Focus gating for RSVP controls:
    let stageActive = false;

    // Chapter state
    let currentBook=null;           // { title, author, chapters:[{title,text}] }
    let currentChapterIndex=-1;     // -1 when not loaded from EPUB
    let currentSourceKey="";        // upload:... or books:...

    // --- Pair short words (display bundle) ---
    const SHORT_WORD_MAX = 2;

    function stripEdgePunct(s){
      return s.replace(/^[("'\[]+|[)"'\].,;:!?]+$/g,"");
    }
    function endsWithPausePunct(s){
      return /[.?!,;:]["')\]]?$/.test(s);
    }
    function isShortWord(s){
      const bare = stripEdgePunct(s);
      return bare.length > 0 && bare.length <= SHORT_WORD_MAX;
    }

    function getDisplayBundle(i){
      if(!tokens.length) return { text:"", advanceBy:1 };

      const t0 = tokens[i]?.value ?? "";
      if(!pairShortWordsBox.checked) return { text: t0, advanceBy: 1 };
      if(i >= tokens.length - 1) return { text: t0, advanceBy: 1 };

      const t1 = tokens[i+1]?.value ?? "";
      if(isShortWord(t0) && isShortWord(t1) && !endsWithPausePunct(t0)){
        return { text: `${t0} ${t1}`, advanceBy: 2 };
      }
      return { text: t0, advanceBy: 1 };
    }

    function refreshTokensAndIndexFromCursor(){
      tokens=tokenizeWithOffsets(editor.value);
      totalLabel.textContent=String(tokens.length);
      const caret=editor.selectionStart ?? 0;
      idx=tokenIndexFromCaret(tokens, caret);
      renderCurrent();
      updateChapterButtons();
    }

    function renderCurrent(){
      if(!tokens.length){
        wordEl.innerHTML=`<span class="pre"></span><span class="orp"></span><span class="post"></span>`;
        idxLabel.textContent="0";
        return;
      }

      idx=Math.max(0,Math.min(idx,tokens.length-1));

      const bundle = getDisplayBundle(idx);
      const token = bundle.text;

      const bare=stripEdgePunct(token);
      const bareStart=token.indexOf(bare);
      const anchorInBare=orpIndex(bare);
      const anchor=Math.max(0,Math.min(token.length-1,bareStart+anchorInBare));

      wordEl.innerHTML=buildWordHTML(token,anchor);
      positionWordAtAnchor(wordEl, token, anchor);

      idxLabel.textContent=String(idx+1);
    }

    function stepForward(){
      if(!tokens.length) return;
      const bundle = getDisplayBundle(idx);
      idx = Math.min(tokens.length-1, idx + bundle.advanceBy);
      renderCurrent();
      updateChapterButtons();
    }
    function stepBack(){
      if(!tokens.length) return;
      idx = Math.max(0, idx - 1);
      renderCurrent();
      updateChapterButtons();
    }
    function rewind(n){
      if(!tokens.length) return;
      idx=Math.max(0, idx-n);
      renderCurrent();
      updateChapterButtons();
    }

    function getWPM(){ return Number(wpmNum.value)||350; }
    function syncWpmInputs(from){
      const v=Math.max(100,Math.min(900, Number(from.value)||350));
      wpmRange.value=String(v); wpmNum.value=String(v);
    }

    function moveCaretToEnd(){
      const pos = editor.value.length;
      editor.focus({ preventScroll: true });
      editor.setSelectionRange(pos, pos);
      editor.scrollTop = editor.scrollHeight;
    }

    function moveCaretToCurrentToken(){
      if(!tokens.length){ moveCaretToEnd(); return; }

      // If we're at end of chapter, move caret to end (your request)
      if(idx >= tokens.length - 1){
        moveCaretToEnd();
        return;
      }

      const t=tokens[Math.max(0, Math.min(idx, tokens.length-1))];
      const pos=t.start;
      editor.focus({ preventScroll: true });
      editor.setSelectionRange(pos, pos);

      const before = editor.value.slice(0, pos);
      const lineCount = before.split("\n").length - 1;
      const approxLineHeight = 20;
      const targetY = Math.max(0, (lineCount * approxLineHeight) - editor.clientHeight / 3);
      editor.scrollTop = targetY;
    }

    function scheduleNextTick(){
      clearTimeout(timerId); timerId=null;
      if(!isHeld || !tokens.length) return;

      const wpm=getWPM();
      const smart=smartPausesBox.checked;

      const bundle = getDisplayBundle(idx);
      const token = bundle.text;

      let ms=baseMsPerWord(wpm);
      ms+=extraPauseMs(token, smart);
      ms+=longWordBonusMs(token, smart);

      timerId=setTimeout(()=>{
        if(!isHeld) return;

        const adv = getDisplayBundle(idx).advanceBy;
        const nextIdx = idx + adv;

        if(nextIdx <= tokens.length-1){
          idx = Math.min(tokens.length-1, nextIdx);
          renderCurrent();
          updateChapterButtons();

          if(idx >= tokens.length-1){
            // stop at end (do NOT move caret here ‚Äî it will happen on release/tap)
            setHeld(false, { reason: "end" });
            return;
          }

          scheduleNextTick();
        } else {
          setHeld(false, { reason: "end" });
        }
      }, ms);
    }

    function setHeld(held, meta = {}){
      const wasHeld = isHeld;
      isHeld=held;

      statusPill.textContent=held ? "Playing (held)" : "Paused";
      statusPill.style.borderColor=held ? "rgba(92,200,255,0.5)" : "rgba(255,255,255,0.08)";

      if(held){
        scheduleNextTick();
      } else {
        clearTimeout(timerId); timerId=null;

        // On release: move caret to current token OR end if finished.
        // Also: if we ended while still holding, the next keyup/release should put caret at end.
        if(wasHeld && meta.reason === "release"){
          moveCaretToCurrentToken();
        }
        // If user releases after we've already ended (wasHeld==false), still move caret to end if at end.
        if(!wasHeld && meta.reason === "release"){
          if(tokens.length && idx >= tokens.length-1) moveCaretToEnd();
        }

        updateChapterButtons();
      }
    }

    // ---------------------- Layout helpers ----------------------
    function isPhone(){ return window.matchMedia("(max-width: 920px)").matches; }
    function touchMode(){ return window.matchMedia("(pointer: coarse)").matches; }

    function showRSVPPhone(){
      document.body.classList.remove("phoneShowText");
      document.body.classList.add("phoneShowRSVP");
      toggleTextBtn.textContent = "Show text";
    }
    function showTextPhone(){
      document.body.classList.remove("phoneShowRSVP");
      document.body.classList.add("phoneShowText");
      toggleTextBtn.textContent = "Hide text";
    }
    function setDesktopTextHidden(hidden){
      document.body.classList.toggle("textHidden", hidden);
      toggleTextBtn.textContent = hidden ? "Show text" : "Hide text";
    }

    function updateFooterHint(){
      if(touchMode()){
        footerHint.textContent = "Touch & hold the display to play. Release to pause.";
      } else {
        footerHint.innerHTML = `Click the RSVP display to focus, then <span class="kbd">Space</span> hold. <span class="kbd">‚Üê</span>/<span class="kbd">‚Üí</span> step. <span class="kbd">‚Üë</span>/<span class="kbd">‚Üì</span> speed.`;
      }
    }

    function applyInitialLayout(){
      document.body.classList.remove("phoneShowRSVP","phoneShowText");
      if(isPhone()){
        document.body.classList.add("phoneShowRSVP");
        toggleTextBtn.textContent = "Show text";
      }else{
        toggleTextBtn.textContent = document.body.classList.contains("textHidden") ? "Show text" : "Hide text";
      }
      updateFooterHint();
    }
    
    function isTextPaneVisible(){
      // Phone: visible only if explicitly in text view
      if (isPhone()) return document.body.classList.contains("phoneShowText");
      // Desktop: visible unless textHidden
      return !document.body.classList.contains("textHidden");
    }


    // ---------------------- Chapter buttons ----------------------
    function hasPrevChapter(){
      return !!(currentBook && currentChapterIndex > 0);
    }
    function hasNextChapter(){
      return !!(currentBook && currentChapterIndex >= 0 && currentChapterIndex < currentBook.chapters.length - 1);
    }

    function updateChapterChip(){
      if(currentBook && currentChapterIndex >= 0){
        chapterChip.textContent = `Chapter: ${currentChapterIndex + 1}/${currentBook.chapters.length}`;
      } else {
        chapterChip.textContent = "Chapter: ‚Äî";
      }
    }

    function updateChapterButtons(){
      // Only enable chapter buttons when stage is active (so they don't "overlay" text editing workflow)
      const allow = stageActive || isPhone(); // on phone, stage is the main surface
      prevChapterBtn.disabled = !(allow && hasPrevChapter());
      nextChapterBtn.disabled = !(allow && hasNextChapter());
      updateChapterChip();
    }

    function loadChapter(i){
      if(!currentBook) return;
      const ch=currentBook.chapters[i];
      if(!ch) return;
    
      setHeld(false);
      currentChapterIndex = i;
    
      editor.value = ch.text + "\n";
    
      // Put caret at start, but only focus editor if the text pane is visible.
      if (isTextPaneVisible()){
        editor.focus({ preventScroll: true });
        editor.setSelectionRange(0, 0);
      } else {
        // Still set selection (some browsers allow it without focus; if not, it doesn't hurt)
        try { editor.setSelectionRange(0, 0); } catch {}
      }
    
      setActiveChapterUI(i);
      refreshTokensAndIndexFromCursor();
    
      // If text is hidden (desktop) or we're on phone RSVP view, keep RSVP focused + active
      if (!isTextPaneVisible()){
        setStageActive(true);
        stageEl.focus({ preventScroll: true });
      }
    
      // Keep your existing behavior: on phone, after choosing a chapter, show RSVP
      if(isPhone()) showRSVPPhone();
    }


    function loadPrevChapter(){ if(hasPrevChapter()) loadChapter(currentChapterIndex - 1); }
    function loadNextChapter(){ if(hasNextChapter()) loadChapter(currentChapterIndex + 1); }

    prevChapterBtn.addEventListener("click", ()=>{ if(stageActive || isPhone()) loadPrevChapter(); });
    nextChapterBtn.addEventListener("click", ()=>{ if(stageActive || isPhone()) loadNextChapter(); });

    prevChapterBtn.addEventListener("pointerdown", (e)=>e.stopPropagation(), {passive:true});
    nextChapterBtn.addEventListener("pointerdown", (e)=>e.stopPropagation(), {passive:true});

    // ---------------------- Stage focus gating ----------------------
    function setStageActive(active){
      stageActive = active;
      stageEl.classList.toggle("stageActive", active);
      updateChapterButtons();
    }

    stageEl.addEventListener("focus", ()=>setStageActive(true));
    stageEl.addEventListener("blur", ()=>setStageActive(false));

    // Clicking inside stage should focus it
    stageEl.addEventListener("pointerdown", ()=>{
      stageEl.focus({ preventScroll: true });
    }, {passive:true});

    // If editor gets focus, stage becomes inactive
    editor.addEventListener("focus", ()=>setStageActive(false));

    // ---------------------- UI wiring ----------------------
    wpmRange.addEventListener("input", ()=>syncWpmInputs(wpmRange));
    wpmNum.addEventListener("input", ()=>syncWpmInputs(wpmNum));

    showGuideBox.addEventListener("change", ()=>{
      anchorGuide.style.display = showGuideBox.checked ? "block" : "none";
    });

    pairShortWordsBox.addEventListener("change", ()=>{
      renderCurrent();
    });

    editor.addEventListener("input", ()=>{
      const caret=editor.selectionStart ?? 0;
      tokens=tokenizeWithOffsets(editor.value);
      totalLabel.textContent=String(tokens.length);
      idx=tokenIndexFromCaret(tokens, caret);
      renderCurrent();
      updateChapterButtons();
    });
    editor.addEventListener("click", refreshTokensAndIndexFromCursor);
    editor.addEventListener("keyup", refreshTokensAndIndexFromCursor);

    rewindBtn.addEventListener("click", ()=>rewind(10));
    backBtn.addEventListener("click", ()=>{ setHeld(false); stepBack(); });
    forwardBtn.addEventListener("click", ()=>{ setHeld(false); stepForward(); });
    resetBtn.addEventListener("click", ()=>{ setHeld(false); refreshTokensAndIndexFromCursor(); });

    toggleTextBtn.addEventListener("click", ()=>{
      setHeld(false);
      if(isPhone()){
        if(document.body.classList.contains("phoneShowRSVP")) showTextPhone();
        else showRSVPPhone();
      } else {
        setDesktopTextHidden(!document.body.classList.contains("textHidden"));
      }
      updateFooterHint();
    });

    window.addEventListener("resize", ()=>{
      applyInitialLayout();
      renderCurrent();
      updateChapterButtons();
    });

    // Desktop keyboard controls (ONLY when stage is active)
    window.addEventListener("keydown", (e)=>{
      if(!stageActive) return; // <--- key point: don't hijack typing in editor

      if(e.code==="Space") e.preventDefault();

      if(e.code==="Space"){
        if(e.repeat) return;
        if(spaceDown) return;
        spaceDown = true;

        if(!isHeld){
          refreshTokensAndIndexFromCursor();
          setHeld(true);
          if(isPhone() && document.body.classList.contains("phoneShowText")) showRSVPPhone();
        }
        return;
      }

      if(e.code==="ArrowRight"){ e.preventDefault(); setHeld(false); stepForward(); }
      if(e.code==="ArrowLeft"){  e.preventDefault(); setHeld(false); stepBack(); }
      if(e.code==="ArrowUp"){
        e.preventDefault(); setHeld(false);
        const v=Math.min(900, getWPM()+10);
        wpmNum.value=String(v); syncWpmInputs(wpmNum);
      }
      if(e.code==="ArrowDown"){
        e.preventDefault(); setHeld(false);
        const v=Math.max(100, getWPM()-10);
        wpmNum.value=String(v); syncWpmInputs(wpmNum);
      }
      if(e.code==="Escape"){ e.preventDefault(); setHeld(false); }
    }, {passive:false});

    window.addEventListener("keyup", (e)=>{
      if(e.code==="Space"){
        // Even if stage isn't active anymore, release should stop playback if it was held
        // (and move caret to current/end)
        e.preventDefault();
        spaceDown = false;
        setHeld(false, { reason: "release" });
      }
    }, {passive:false});

    // Mobile/touch: press-and-hold on the RSVP stage (taps also imply stage active)
    stageEl.addEventListener("contextmenu", (e)=>e.preventDefault());

    stageEl.addEventListener("pointerdown", (e)=>{
      if(!touchMode()) return;
      e.preventDefault();
      stageEl.setPointerCapture(e.pointerId);
      setStageActive(true);

      if(!isHeld){
        refreshTokensAndIndexFromCursor();
        setHeld(true);
        if(isPhone() && document.body.classList.contains("phoneShowText")) showRSVPPhone();
      }
    }, {passive:false});

    function stopFromPointerRelease(e){
      if(!touchMode()) return;
      e.preventDefault();
      if(isHeld) setHeld(false, { reason: "release" });
      // On phone: if we are at end and user releases, ensure caret moves to end too
      if(tokens.length && idx >= tokens.length-1) moveCaretToEnd();
    }
    stageEl.addEventListener("pointerup", stopFromPointerRelease, {passive:false});
    stageEl.addEventListener("pointercancel", stopFromPointerRelease, {passive:false});
    stageEl.addEventListener("pointerleave", stopFromPointerRelease, {passive:false});

    // ---------------------- EPUB + books dropdown ----------------------
    const epubFile=document.getElementById("epubFile");
    const epubMeta=document.getElementById("epubMeta");
    const epubError=document.getElementById("epubError");
    const chapterList=document.getElementById("chapterList");
    const chapCount=document.getElementById("chapCount");
    const bookDropdown=document.getElementById("bookDropdown");

    function setError(msg){ epubError.textContent=msg||""; }
    function clearChaptersUI(){ chapterList.innerHTML=""; chapCount.textContent="0"; }

    function setActiveChapterUI(i){
      const buttons=chapterList.querySelectorAll(".chapterItem");
      buttons.forEach((b,idx)=>b.classList.toggle("active", idx===i));
    }

    function normalizePath(basePath, rel){
      if(!rel) return rel;
      if(/^[a-z]+:\/\//i.test(rel)) return rel;
      if(rel.startsWith("/")) rel=rel.slice(1);
      const baseDir = basePath.includes("/") ? basePath.slice(0, basePath.lastIndexOf("/")+1) : "";
      const stack=(baseDir+rel).split("/");
      const out=[];
      for(const part of stack){
        if(!part || part===".") continue;
        if(part==="..") out.pop();
        else out.push(part);
      }
      return out.join("/");
    }

    function parseXml(xmlStr){ return new DOMParser().parseFromString(xmlStr,"application/xml"); }
    function firstText(el, selector){
      const node=el.querySelector(selector);
      return node ? (node.textContent||"").trim() : "";
    }

    function extractReadableTextFromXhtml(xhtmlStr){
      const doc=new DOMParser().parseFromString(xhtmlStr,"text/html");
      doc.querySelectorAll("script, style, nav, header, footer").forEach(n=>n.remove());
      const body=doc.body; if(!body) return "";
      const blockSelectors="p,div,section,article,h1,h2,h3,h4,h5,h6,li,br";
      body.querySelectorAll(blockSelectors).forEach(el=>{
        if(el.tagName.toLowerCase()==="br") el.replaceWith(doc.createTextNode("\n"));
        else el.insertAdjacentText("afterend","\n");
      });
      let text=body.textContent||"";
      text=text.replace(/\r/g,"");
      text=text.replace(/[ \t]+\n/g,"\n");
      text=text.replace(/\n{3,}/g,"\n\n");
      text=text.replace(/[ \t]{2,}/g," ");
      return text.trim();
    }

    async function readZipText(zip, path){
      const f=zip.file(path);
      if(!f) return null;
      return await f.async("string");
    }

    async function loadEpubArrayBuffer(buf, displayName){
      setError(""); clearChaptersUI();
      epubMeta.textContent=`Loading: ${displayName} ...`;

      const zip=await JSZip.loadAsync(buf);

      const containerStr=await readZipText(zip,"META-INF/container.xml");
      if(!containerStr) throw new Error("Invalid EPUB: META-INF/container.xml not found.");

      const containerXml=parseXml(containerStr);
      const rootfile=containerXml.querySelector("rootfile");
      const opfPath=rootfile?.getAttribute("full-path");
      if(!opfPath) throw new Error("Invalid EPUB: OPF path not found in container.xml.");

      const opfStr=await readZipText(zip, opfPath);
      if(!opfStr) throw new Error(`Invalid EPUB: OPF file not found at ${opfPath}.`);

      const opfXml=parseXml(opfStr);

      const title = firstText(opfXml,"metadata > title") ||
                    firstText(opfXml,"metadata > dc\\:title") ||
                    firstText(opfXml,"dc\\:title") ||
                    displayName;
      const author = firstText(opfXml,"metadata > creator") ||
                     firstText(opfXml,"metadata > dc\\:creator") ||
                     firstText(opfXml,"dc\\:creator");

      epubMeta.textContent = author ? `${title} ‚Äî ${author}` : `${title}`;

      const manifest=new Map();
      opfXml.querySelectorAll("manifest > item").forEach(item=>{
        const id=item.getAttribute("id");
        const href=item.getAttribute("href");
        const media=item.getAttribute("media-type")||"";
        if(id && href) manifest.set(id,{href:normalizePath(opfPath,href), media});
      });

      const spineIds=[];
      opfXml.querySelectorAll("spine > itemref").forEach(ir=>{
        const idref=ir.getAttribute("idref");
        if(idref) spineIds.push(idref);
      });

      const chapters=[];
      for(const id of spineIds){
        const item=manifest.get(id);
        if(!item) continue;
        const {href, media}=item;
        const ok = media.includes("application/xhtml+xml") || media.includes("text/html") ||
                   href.toLowerCase().endsWith(".xhtml") || href.toLowerCase().endsWith(".html") || href.toLowerCase().endsWith(".htm");
        if(!ok) continue;

        const xhtml=await readZipText(zip, href);
        if(!xhtml) continue;

        const doc=new DOMParser().parseFromString(xhtml,"text/html");
        const t=(doc.querySelector("title")?.textContent||"").trim();
        const h=(doc.querySelector("h1,h2,h3")?.textContent||"").trim();
        const chapterTitle=t || h || `Chapter ${chapters.length+1}`;

        const text=extractReadableTextFromXhtml(xhtml);
        if(!text) continue;

        chapters.push({title:chapterTitle, href, text});
      }

      if(!chapters.length) throw new Error("Could not find readable chapters in this EPUB.");

      currentBook={title, author, chapters};
      currentChapterIndex = 0;

      renderChapterList(chapters);
      loadChapter(0);

      updateChapterButtons();
    }

    async function loadEpubFile(file){
      const buf=await file.arrayBuffer();
      await loadEpubArrayBuffer(buf, file.name);
    }

    function renderChapterList(chapters){
      chapterList.innerHTML="";
      chapCount.textContent=String(chapters.length);

      chapters.forEach((ch,i)=>{
        const btn=document.createElement("button");
        btn.className="chapterItem";
        btn.type="button";
        btn.innerHTML=`<span class="chapterNum">${String(i+1).padStart(2,"0")}</span>
                       <span class="chapterTitle">${escapeHtml(ch.title)}</span>`;
        btn.addEventListener("click", ()=>loadChapter(i));
        chapterList.appendChild(btn);
      });
    }

    // File input
    epubFile.addEventListener("change", async ()=>{
      const file=epubFile.files?.[0];
      if(!file) return;
      try{
        currentSourceKey = "upload:" + file.name;
        bookDropdown.value = "";
        await loadEpubFile(file);
        setError("");
      }catch(err){
        console.error(err);
        currentBook=null;
        currentChapterIndex=-1;
        updateChapterButtons();
        epubMeta.textContent="No book loaded.";
        clearChaptersUI();
        setError(String(err?.message || err));
      }finally{
        epubFile.value="";
      }
    });

    // Books/ manifest dropdown (Option A)
    async function loadBooksManifest(){
      try{
        const resp = await fetch("books/index.json", { cache: "no-store" });
        if(!resp.ok) throw new Error("books/index.json not found (need to serve via http).");
        const data = await resp.json();

        if(!Array.isArray(data) || data.length===0){
          bookDropdown.innerHTML = `<option value="">No books in books/index.json</option>`;
          return;
        }

        bookDropdown.innerHTML = `<option value="">Choose a book from books/‚Ä¶</option>`;
        for(const item of data){
          if(!item || typeof item.file!=="string") continue;
          const title = (typeof item.title==="string" && item.title.trim()) ? item.title.trim() : item.file;
          const opt = document.createElement("option");
          opt.value = item.file;
          opt.textContent = title;
          bookDropdown.appendChild(opt);
        }
      }catch(err){
        bookDropdown.innerHTML = `<option value="">(books/ list unavailable)</option>`;
        setError("To use the books/ dropdown, run a local server and create books/index.json. Example: python -m http.server");
      }
    }

    bookDropdown.addEventListener("change", async ()=>{
      const file = bookDropdown.value;
      if(!file) return;

      const key = "books:" + file;
      if(key === currentSourceKey) return;

      try{
        currentSourceKey = key;
        setHeld(false);

        const resp = await fetch("books/" + file, { cache: "no-store" });
        if(!resp.ok) throw new Error(`Could not load books/${file}`);
        const buf = await resp.arrayBuffer();

        epubFile.value = "";
        await loadEpubArrayBuffer(buf, file);
        setError("");
      }catch(err){
        console.error(err);
        currentBook=null;
        currentChapterIndex=-1;
        updateChapterButtons();
        epubMeta.textContent="No book loaded.";
        clearChaptersUI();
        setError(String(err?.message || err));
      }
    });

    // ---------------------- Init ----------------------
    syncWpmInputs(wpmNum);
    refreshTokensAndIndexFromCursor();
    anchorGuide.style.display = showGuideBox.checked ? "block" : "none";
    applyInitialLayout();
    loadBooksManifest();

    // Stage starts inactive on desktop
    setStageActive(isPhone());
    updateChapterButtons();
  </script>
</body>
</html>
